#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# rh: 2009-10_02
# rh: 2014-03_29   vs 0.2
# rh: 2016-04_09   vs 0.3
#
# Version um:
# 1. die Morgenphotos umzubenennen: YYYY_MM_DD_HH_mm_SS_IMGxxxx.jpg
# 2. Belichtungszeit, FNumber und ISOSpeed zu extrahieren
# 3. CSV File zu erstellen mit fn, Uhrzeit, ExpoTime, F und ISOSpeed
# 4. Fehlende Bilder ersetzen (496 = 2**4  * 31)  # 497 möglich
#
# Output:
# 1. neuen Filenamen samt Path
# 2. (Batchfile)
#
# https://pypi.python.org/pypi/ExifRead
#
## Für jedes Bild soll ein Objekt (iS eines -> data members) angelegt werden, das in einer Liste landet.
## Listen von Data member kann man auch gut sortieren:
##   http://stackoverflow.com/questions/403421/how-to-sort-a-list-of-objects-in-python-based-on-an-attribute-of-the-objects
## Dicts und Listen von DIcts kann man auch gut sortieren:
## https://wiki.python.org/moin/HowTo/Sorting  -> 'itemgetter' !!
##
## TODO list of pictures:
## stich pic's together
## http://stackoverflow.com/questions/10657383/stitching-photos-together
## Geht mit pil

import csv
import datetime
import getopt
import json
import os
import pprint
import random
import re
import sys
from operator import itemgetter, attrgetter, methodcaller
from fractions import Fraction

import exifread
# https://books.google.de/books?id=YRHSCgAAQBAJ&pg=PA96&lpg=PA96&dq=pil+average+grayscale&source=bl&ots=tsJ8nbYvua&sig=OHKPOAlTMV08S-p5jS-t_RacTS0&hl=de&sa=X&ved=0ahUKEwjrxo2I2JHMAhWEJhoKHY_rB0cQ6AEIRzAE#v=onepage&q=pil%20average%20grayscale&f=false
import numpy as np
from PIL import Image

list_of_pict   = []
List_FNumbers  = []
List_ExpoTimes = []
List_ISOSpeeds = []

List_FNumbers_float  = []
List_ExpoTimes_float = []
List_ISOSpeeds_float = []


# show command line usage
def usage(exit_status):
    msg = 'Usage: Photos_Rename.py [OPTIONS] \n'
    msg += 'Extract EXif information from JPEG files.\n'
    msg += 'Creates >rename_photos.bat< to rename pictures with hhmm-prefix \n'
    msg += 'i.e. hour and minute of exposure\n'
    msg += '\n'
    msg += 'Options:\n'
    msg += '  -v --verbose  verbose.\n'
    msg += '  -a --avrge    calc average gray value.\n'
    msg += '  -d --dir=     directory.\n'
    msg += '  -s --syn      synthesize new images\n'
    msg += '  -q --quiet    quiet (default)\n'
    msg += '\n'
    print msg
    if exit_status:
        sys.exit(exit_status)

def get_opts_args():
    quiet = True
    global root_dir
    global do_calc_average
    global do_make_rename_file
    global batch_file
    global batch_f_name

    try:
        #  >:< option requires argument
        opts, args = getopt.getopt(sys.argv[1:], "abd:hvqs", ["avrge", "batch", "dir=", "verbose", "quiet", "syn"])
    except getopt.GetoptError:
        usage(2)
    if not args:
        usage(0)

    for o, a in opts:
        if o in ("-a", "--avrge"):
            do_calc_average = True
        if o in ("-b", "--batch"):
            do_make_rename_file = True
        if o in ("-d", "--dir"):
            root_dir = a
        if o in ("-s", "--syn"):
            do_make_new_images = True
        if o in ("-w", "--write_files"):
            do_write_files = True
        if o in ("-h", "--help"):
            usage(0)

    if not root_dir:
        root_dir = '.'

    if not quiet:
        print 'root_dir: >' + root_dir + '<'
    if not os.path.isdir(root_dir):
        print 'Directory >' + root_dir + '< does not exist.'
        sys.exit(2)

    if do_make_rename_file:
        try:
            batch_f_name = 'rename_photos.bat'
            batch_f_name = os.path.join(root_dir, batch_f_name)
            batch_file = open(batch_f_name, 'wb')
        except:
            print "'%s' is unwritable\n" % batch_f_name
            sys.exit(2)

    return root_dir, quiet, do_calc_average, do_make_rename_file

# http://www.tutorialspoint.com/python/python_classes_objects.htm
class PictClass(object):
    def __init__(self, param):
        if type (param) == str: # param == datum
            datum = param
            self.cnt         = '0'
            self.datum       = datum
            self.date        = ''
            self.Make        = 'rh'
            self.Model       = 'ToDo'
            self.date        = ''
            self.fn          = datum + '_' + '0900_IMG_rh.JPG'
            self.fn_old      = '0900_IMG_rh.JPG'         # default
            self.path_fn     = ''
            self.FNumber_str = ''
            self.FNumber     = ''
            self.ExpoTime_str= ''
            self.ExpoTime    = ''
            self.ISOSpeed    = ''
            self.ISOSpeed_str= ''
            self.av_gray     = '99'
            self.sources     = ''
        elif type (param) == dict:
            dct = param
            for k, v in dct.items():
                setattr(self, k, v)
        else:
            print '>pict< cannot be initialized with type: >' + type(param) + '< .'
            sys.exit(2)

    def __repr__(self):
        return '%s; '*16 % ( \
        self.cnt ,
        self.datum , \
        self.Make , \
        self.Model , \
        self.date , \
        self.fn , \
        self.fn_old , \
        self.path_fn , \
        self.FNumber_str , \
        self.FNumber , \
        self.ExpoTime_str , \
        self.ExpoTime , \
        self.ISOSpeed , \
        self.ISOSpeed_str , \
        self.av_gray , \
        self.sources )


    fieldnames = [ "cnt",
        "datum", "Make", "Model",
        "date", "fn", "fn_old", "path_fn",
        "FNumber_str" , "FNumber",
        "ExpoTime_str", "ExpoTime",
        "ISOSpeed", "ISOSpeed_str",
        "av_gray",
        "sources"]


def make_regex_YMDHm_word():
    # URL that generated this code: http://txt2re.com/
    # regex matching: >'2013_09_17_1937_IMG_9930.JPG'<
    re1 = '((?:(?:[1]{1}\\d{1}\\d{1}\\d{1})|(?:[2]{1}\\d{3})))(?![\\d])'  # Year 1
    re2 = '(_)'  # Any Single Character 1
    re3 = '(\\d)'  # Any Single Digit 1
    re4 = '(\\d)'  # Any Single Digit 2
    re5 = '(_)'  # Any Single Character 2
    re6 = '(\\d)'  # Any Single Digit 3
    re7 = '(\\d)'  # Any Single Digit 4
    re8 = '(_)'  # Any Single Character 3
    re9 = '(\\d)'  # Any Single Digit 5
    re10 = '(\\d)'  # Any Single Digit 6
    re11 = '(\\d)'  # Any Single Digit 7
    re12 = '(\\d)'  # Any Single Digit 8
    re13 = '(_)'  # Any Single Character 4
    re14 = '((?:[a-z][a-z]+))'  # Word 1
    re15 = '.*?'  # Non-greedy match on filler
    re16 = '(\\.)'  # Any Single Character 5
    re17 = '((?:[a-z][a-z]+))'  # Word 2

    rgx = re.compile(
        re1 + re2 + re3 + re4 + re5 + re6 + re7 + re8 + re9 + re10 + re11 + re12 + re13 + re14 + re15 + re16 + re17,
        re.IGNORECASE | re.DOTALL)
    # txt='2013_09_17_1937_IMG_9930.JPG'
    # m = rgx.search(txt)
    # if m: print 'ok'
    return rgx

def print_list_of_existing_picts(list_of_pict=list_of_pict):
    list_of_pict.sort(key = attrgetter('Model', 'datum'))
    picts_cnt = 0
    for pict in list_of_pict:
        # pprint.pprint(pict)
        if pict.Model != 'ToDo':
            picts_cnt += 1
            if not quiet:
                print '{:4d}'.format(picts_cnt), pict
        else:
            if not quiet:
                print 'Model = rh: ', pict
            pass
    return picts_cnt

def print_all_existing_picts():
    list_of_pict.sort(key = attrgetter('Model', 'datum'))
    for pict in list_of_pict:
        pprint.pprint(pict)

def print_list_of_missing_picts():
    list_of_pict.sort(key = attrgetter('Model', 'datum'))
    picts_cnt = 0
    for pict in list_of_pict:
        if pict.Model == 'ToDo':
            picts_cnt += 1
            print str(picts_cnt) + ': ', pict
    return picts_cnt

def initialize_list_of_picts():
    # >list_of_pict< is global
    global days_cnt
    date1   = '2013_04_07'
    date2   = '2014_08_16'
    start   = datetime.datetime.strptime(date1, '%Y_%m_%d')
    end     = datetime.datetime.strptime(date2, '%Y_%m_%d')
    step    = datetime.timedelta(days=1)
    days_cnt= 0
    act_day = start
    while act_day <= end:
        act_day_str = act_day.date().strftime('%Y_%m_%d')  # Formatieren
        pict = PictClass(act_day_str)
        pict.cnt = days_cnt
        list_of_pict.append(pict)
        act_day  += step
        days_cnt +=  1

def make_list_of_picts_via_EXIF():
    # >list_of_pict< is global
    stop_tag = 'UNDEF'
    reg_hhmm  = re.compile(r"^\d{4}_[A-Za-z]")
    reg_YMDHm = make_regex_YMDHm_word()#
    # reg_YYYY_MM_DD_hhmm = re.compile(r"^\d{4}_[A-Za-z]")  #
    cnt_picts_ok = 0
    root, dirs, files = os.walk(root_dir).next()  # only first level
    for f_name in files:  # only files
        path_f_name = os.path.join(root, f_name)
        ext = os.path.splitext(path_f_name)[-1].lower()  # get fn-extension
        if ext == ".jpg":
            cnt_picts_ok += 1
            # print '\n', '{:4d}'.format(cnt_jpg_picts), ': ', f_name

            new_f_name = '*'
            new_path_f_name = '*'

            Make = 'Manufacturer_?'
            Model = 'Model_?'
            date_time_str = '0'
            FNumber = '0'
            ExposureTime = '0'
            ISOSpeed = '0'

            try:
                im_file = open(path_f_name, 'rb')
            except:
                print "'%s' is unreadable\n" % path_f_name
                continue
            # get EXif tags:
            data = exifread.process_file(im_file, details=False)
            im_file.close()

            for key in data.keys():
                if key.find('Item') >= 0:  # dummy for pattern
                    Item = data[key].printable  # dummy for pattern

                if key.find('Make') >= 0:
                    Make = data[key].printable  # Manufacturer
                    # print 'Make =', Make

                if key.find('Model') >= 0:
                    Model = data[key].printable
                    if 'G1 X' in Model:
                        Model = 'G1 X'
                    if 'G15' in Model:
                        Model = 'G15 '

                if key.find('FNumber') >= 0:
                    FNumber_str = data[key].printable
                    # print 'FNumber =', FNumber_str
                    pos_slash = FNumber_str.find('/')
                    if pos_slash > 0:
                        counter = FNumber_str[:pos_slash]
                        denominator = FNumber_str[pos_slash + 1:]
                        FNumber = str(float(counter) / float(denominator))
                    else:
                        FNumber = str(float(FNumber_str))
                        # print 'FNumber =', FNumber

                if key.find('ExposureTime') >= 0:
                    ExposureTime = data[key].printable
                    # print 'ExposureTime =', ExposureTime,
                    pos_slash = ExposureTime.find('/')
                    if pos_slash > 0:
                        z = ExposureTime[:pos_slash]
                        n = ExposureTime[pos_slash + 1:]
                        ExposureTime_float = float(z) / float(n)
                    # print '= ', ExposureTime_float

                if key.find('ISOSpeed') >= 0:
                    ISOSpeed = data[key].printable
                    # print 'ISOSpeed =', ISOSpeed

                if key.find('DateTimeOriginal') >= 0:
                    date_time_str = data[key].printable
                    hhmm_prefix = date_time_str[11:13] + date_time_str[14:16]
                    hhmm_prefix = hhmm_prefix.replace(' ', '0', -1)

                    Y_M_D_prefix = date_time_str[0:4] + '_' + date_time_str[5:7] + '_' + date_time_str[8:10]
                    YMDHm_prefix = Y_M_D_prefix + '_' + hhmm_prefix
                    if not quiet: print Y_M_D_prefix, YMDHm_prefix
                    if re.match(reg_hhmm, f_name):  # re.match == regex am Stringanfang?
                        new_f_name = YMDHm_prefix + '_' + f_name[5:]
                    elif reg_YMDHm.search(f_name):
                        new_f_name = YMDHm_prefix + '_' + f_name[16:]
                    else:
                        new_f_name = YMDHm_prefix + '_' + f_name

            # f_name = basename(path_f_name)
            # find pict in list_of_pict with pict.datum == Y_M_D_prefix
            new_path_f_name = os.path.join(root, new_f_name)
            pict = next((x for x in list_of_pict if x.datum == Y_M_D_prefix), None)
            if pict.date:
                print '!!! >>>> ', pict.date, ' exists ! <<<< '
            else:
                pict.date        = Y_M_D_prefix
                pict.Make        = Make
                pict.Model       = Model
                pict.fn          = new_f_name
                pict.fn_old      = f_name
                pict.path_fn     = new_path_f_name   # fn incl path
                pict.FNumber_str = FNumber_str
                pict.FNumber     = FNumber
                pict.ExpoTime_str= ExposureTime
                pict.ExpoTime    = ExposureTime_float # ExposureTime
                pict.ISOSpeed    = ISOSpeed
                pict.ISOSpeed_str= ISOSpeed
                pict.av_gray     = 99

    cnt_picts_ok = 0
    for pict in list_of_pict:
        if pict.Model != 'ToDo':  # == missing image == to be synthesized
            cnt_picts_ok += 1
    return cnt_picts_ok

def make_result_path_fn (dir, fn):
    return os.path.join(root_dir,dir, fn)

def picts_show_class_members(list_of_pict):
    for pict in list_of_pict:
        print '\n -------------- \n'
        for k, v in vars(pict).items():
            print 'k= ', k, 'v= ', v

def picts_csv_write(list_of_pict):
    # >PictClass< erbt von >object< => >pict.__dict__< ist ein dictionary und kann mit >csv.DictWriter< serialisiert werden.
    # http://stackoverflow.com/questions/61517/python-dictionary-from-an-objects-fields
    # http://stackoverflow.com/questions/3086973/how-do-i-convert-this-list-of-dictionaries-to-a-csv-file-python
    fn = make_result_path_fn('result', 'picts.csv')   # fn von csv file
    list_of_pict.sort(key = attrgetter('Model', 'datum'))
    pict = list_of_pict[0]                            # erstes Element von >list_of_pict<
    fieldnames = pict.fieldnames                      # >fieldnames< from definition of PictClass
    with open(fn, 'wb') as csv_file:
        writer = csv.DictWriter(csv_file, fieldnames)
        writer.writeheader()                          # Header = >fieldnames<
        for pict in list_of_pict:
            # print pict.__dict__
            writer.writerow(pict.__dict__)            # write values of dictionary: >pict.__dict__<. dictionary!!
    # pprint.pprint(fieldnames)

def picts_csv_read():
    # (SilentGhost' answer is helpfull) but here we use _existing_ class -> simply adapt __init__
    # http://stackoverflow.com/questions/1639174/creating-class-instance-properties-from-a-dictionary-in-python
    fn = make_result_path_fn('result', 'picts.csv')
    new_list_of_pict = []
    with open(fn, 'r') as csv_file:
        reader = csv.DictReader(csv_file)
        for pict_dict in reader:
            if not quiet:
                print pict_dict          # is a dict
            pict = PictClass(pict_dict)
            new_list_of_pict.append(pict)
    return new_list_of_pict

def make_rename_batch_file():
    list_of_pict.sort(key = attrgetter('Model', 'datum'))
    cnt_picts = 0
    for pict in list_of_pict:
        if (pict.Make != 'rh') and (pict.fn_old != pict.fn):
            cnt_picts += 1
            batch_str = 'mv %s %s ' % (pict.fn_old , pict.fn)
            batch_file.write(batch_str + '\n')
    return cnt_picts


def calc_model_type_picts():
    # calc's number of images per model
    dict_model_cnt = {}   # {model:cnt}
    list_of_pict.sort(key=attrgetter('Model', 'datum')) # sort list_of_pict

    for pict in list_of_pict:
        if pict.Model not in dict_model_cnt.keys():
            dict_model_cnt[pict.Model] = 1
        else:
            dict_model_cnt[pict.Model] = dict_model_cnt[pict.Model] + 1
    list_model_cnt = [] # of model_cnt  <> convert dict to list (better to sort)
    for model, cnt in sorted(dict_model_cnt.iteritems()):
        temp = [model, cnt]
        list_model_cnt.append(temp)

    list_model_cnt.sort(key=lambda x: x[0])
    return list_model_cnt

def split_and_combine_rgb_channels(pict_new, pict_1, pict_2, pict_3):
    im = Image.open(os.path.join(root_dir, pict_1.fn))
    red, g, b = im.split()
    im.close()
    im = Image.open(os.path.join(root_dir, pict_2.fn))
    r, green, b = im.split()
    im.close()
    im = Image.open(os.path.join(root_dir, pict_3.fn))
    r, g, blue = im.split()
    im.close()

    # img = Image.merge("RGB", (red, green, blue))
    attenuated_red = red.point(lambda i: i * 0.85)      # attenuate red channel
    img = Image.merge("RGB", (attenuated_red, green, blue))
    img.save((os.path.join(root_dir, synth_image_dir, pict_new.fn)))

def calc_and_store_FN_ExposureTime_ISOSpeed(pict_new, pict_1, pict_2, pict_3):
    # used lists are global. values are strings or corresponding floats

    global List_FNumbers
    global List_ExpoTimes
    global List_ISOSpeeds

    global List_FNumbers_float
    global List_ExpoTimes_float
    global List_ISOSpeeds_float

    # calc average (FNumber, Expotime, ISOSpeed) from the 3 source images.
    average_FNumber   = (float(pict_1.FNumber) + float(pict_2.FNumber) + float(pict_3.FNumber)) / 3
    average_ExpoTime  = (float(pict_1.ExpoTime) + float(pict_2.ExpoTime) + float(pict_3.ExpoTime)) / 3
    average_ISOSpeed  = (float(pict_1.ISOSpeed) + float(pict_2.ISOSpeed) + float(pict_3.ISOSpeed)) / 3

    # Look for the nearest norm-value by calculating deltas from corresponding list of norm-values
    # Use index to extract nearest value as fraction (as string)
    # val, idx = min((val, idx) for (idx, val) in enumerate(my_list))
    list_delta_FNumber = list(abs(float(x - average_FNumber)) for x in List_FNumbers_float)
    val, idx = min((val, idx) for (idx, val) in enumerate(list_delta_FNumber))
    # print 'delta: ', val, 'idx: ', idx, average_FNumber, List_FNumbers_float[idx], List_FNumbers[idx]
    pict_new.FNumber     = List_FNumbers_float[idx]
    pict_new.FNumber_str = List_FNumbers[idx]

    list_delta_ExpoTime = list(abs(float(x - average_ExpoTime)) for x in List_ExpoTimes_float)
    val, idx = min((val, idx) for (idx, val) in enumerate(list_delta_ExpoTime))
    pict_new.ExpoTime     = List_ExpoTimes_float[idx]
    pict_new.ExpoTime_str = List_ExpoTimes[idx]

    list_delta_ISOSpeed = list(abs(float(x - average_ISOSpeed)) for x in List_ISOSpeeds_float)
    val, idx = min((val, idx) for (idx, val) in enumerate(list_delta_ISOSpeed))
    pict_new.ISOSpeed     = List_ISOSpeeds_float[idx]
    pict_new.ISOSpeed_str = List_ISOSpeeds[idx]

def make_new_images_logstr (cnt, new_pict, pict_s):
    log_str = str(cnt) + ' ; ' + new_pict.fn + ' ; '
    log_str += pict_s[0].Model + ' ; ' + pict_s[0].fn + ' ; '
    log_str += pict_s[1].Model + ' ; ' + pict_s[1].fn + ' ; '
    log_str += pict_s[2].Model + ' ; ' + pict_s[2].fn + ' ; '
    log_str += '\n'
    return log_str

def list_synthesized_images():
    for pict in list_of_pict:
        if pict.Model == 'synthesized': # find synthesized images
            print pict

def make_synthisize_images():
    # following _global_ lists are used in >def calc_and_store_FN_ExposureTime_ISOSpeed<
    #   to calc FN_ExposureTime_ISOSpeed values
    global List_FNumbers
    global List_ExpoTimes
    global List_ISOSpeeds
    List_FNumbers = ["1.4", "1.8", "2", "2.2", "2.4", "2.8", "3.2", "3.5", "4", "4.5", "5", "5.6", "6.3", "6.5", "7.1",
                    "8", "9.5", "10", "11", "13", "16", "19", "22"]
    List_ExpoTimes = ["1/1000", "1/500", "1/250", "1/125", "1/60", "1/30", "1/15", "1/8", "1/4", "1/2", "1"]
    List_ISOSpeeds = ["25", "50", "64", "100", "200", "400", "800", "1600", "3200", "6400", "12800", "25600", "51200",
                     "102400", "204800"]

    global List_FNumbers_float
    global List_ExpoTimes_float
    global List_ISOSpeeds_float
    List_FNumbers_float = list(float(Fraction(x)) for x in List_FNumbers)
    List_ExpoTimes_float = list(float(Fraction(x)) for x in List_ExpoTimes)
    List_ISOSpeeds_float = list(float(Fraction(x)) for x in List_ISOSpeeds)

    # synth images:
    # a) combine r,g,b channels from 3 different images of _same_ camera model (to conserve dimensions, geometry etc)
    # b) relation of camera model of new images reflects relation of camera models of existing images
    # c) o calc FN_ExposureTime_ISOSpeed values by calling function
    # d) log all
    #
    list_model_cnt = calc_model_type_picts()    # list: how many img's from which camera model ?
    iter_list_model_cnt = iter(list_model_cnt)  # convert list to iterator
    model, cnt_g1X = iter_list_model_cnt.next() # idx in list_of_pict of last G1X pict:  first  model (G1 X)
    model, cnt_g15 = iter_list_model_cnt.next() # idx in list_of_pict of last G1X pict:  second model (G15)
    # cnt of all existing images == (cnt_g1X + cnt_g15) == 100%  = 0 .. 1.0
    # cut == percentage of G1X - images; (1 - cut) == percentage of G15 - images
    cut =  float(cnt_g1X) / (float(cnt_g15) + float(cnt_g1X))  # relation cnt_G1X to cnt_G15
    list_of_pict.sort(key=attrgetter('Model', 'datum'))        # sort in place

    log_fn = 'new_images_test.log'                                      # log filename
    log_f  = open(os.path.join(root_dir, synth_image_dir, log_fn), 'w') # log file in sub dir

    cnt = 0
    for pict in list_of_pict:
        if pict.Model == 'ToDo':          # find fn of next image to synthesize
            cnt += 1
            print "\r", 'synthesizing new image # ', cnt,
            pict_to_synth = pict
            if random.random() < cut:   # 1 .. cnt_g1X - 1   == range with G1 X images
                low = 1
                high = cnt_g1X - 1
            else:                       # cnt_g1X .. cnt_g15 == range with G15 images
                low  = cnt_g1X
                high = cnt_g1X + cnt_g15 - 1

            pict_s = []
            for idx in range(0,3):  # 0,1,2 i.e. find 3 images in the same range (with same model) as 'pict_synth'.
                l_pict = list_of_pict[int(round(random.uniform(low, high)))]  # low, high == range of G1X or G15
                pict_s.append(l_pict)

            # print (log_str)
            # synthesize image:
            split_and_combine_rgb_channels(pict_to_synth, pict_s[0], pict_s[1], pict_s[2])
            # store names of source images:
            pict_to_synth.sources = pict_s[0].fn + ', ' + pict_s[1].fn + ', ' + pict_s[2].fn
            # calc virtual FNumber, ExposureTime and ISOSpeed of synthesized image
            calc_and_store_FN_ExposureTime_ISOSpeed (pict_to_synth, pict_s[0], pict_s[1], pict_s[2])
            # mark it as synthesized image
            pict_to_synth.Model   = 'synthesized'
            pict_to_synth.path_fn = (os.path.join(root_dir, synth_image_dir, pict.fn))
            # compose log_str and write it to file
            log_str = make_new_images_logstr(cnt, pict_to_synth, pict_s)
            log_f.write(log_str)

    log_f.close()
    # show what you've done
    list_synthesized_images()


def calc_average_graylevel():
    # print '>>>>>>>> calc_average_graylevel():'
    list_of_pict.sort(key = attrgetter('Model', 'datum'))
    cnt = 0
    for pict in list_of_pict:
        # if pict.Model !=
        cnt += 1
        print "\r  ", cnt, ': image # ', pict.path_fn, ' gray level = ',
        image = Image.open(pict.path_fn).convert('L')
        im_np_array  = np.array(image)
        pict.av_gray = np.average(im_np_array)
        print pict.av_gray


#======================================================================
root_dir        = 'D:\Data_Work\Photos\_Extra\Morgen_Himmel\Morgen_Himmel_alle'
root_dir        = 'D:\Data_Work\Other_Data\Morgen_Himmel\_Morgen_Himmel_alle_001'
synth_image_dir = 'synth_images'
synth_image_dir = ''

do_make_rename_file       = False
do_synthisize_new_images  = True
# do_synthisize_new_images  = False

do_calc_average     = True
# do_calc_average     = False


if __name__ == '__main__':
    root_dir, quiet, do_calc_average, do_make_rename_file = get_opts_args()
    initialize_list_of_picts()

    # >list_of_pict< is global
    cnt_jpg_picts      = make_list_of_picts_via_EXIF()
    cnt_existing_picts = print_list_of_existing_picts()
    cnt_missing_picts  = print_list_of_missing_picts()
    ## print '\n', '{:4d}'.format(cnt_missing_picts), ' fehlen. '

    if do_make_rename_file:
        cnt_picts_to_rename = make_rename_batch_file()
        print "\n\n>" + batch_f_name + "< written. ", cnt_picts_to_rename, "files to rename\n"
        batch_file.close()

    print "\n\n"
    print ">", days_cnt, "days in total"
    print ">", cnt_jpg_picts,      "jpg files in directory \n"
    print ">", cnt_existing_picts, "files in directory \n"
    print ">", cnt_missing_picts,  "missing files in directory \n"

    list_model_cnt = calc_model_type_picts()
    for model, cnt in list_model_cnt:
        print model + ':', cnt

    picts_csv_write(list_of_pict)

    if do_synthisize_new_images:
        print "\n"
        make_synthisize_images()
        print "\n"

    picts_csv_write(list_of_pict)

    if do_calc_average:
        calc_average_graylevel()

    # print_all_existing_picts()
    # picts_show_class_members(list_of_pict)

    picts_csv_write(list_of_pict)
    new_list_of_pict = picts_csv_read()
    cnt_existing_picts = print_list_of_existing_picts(new_list_of_pict)

    print "\n> end"
